1.最开始的识别矩形中心追踪打点，不转圈（激光常亮）
import time, os, sys,gc
import math
import cv_lite  # 导入cv_lite扩展模块
import ulab.numpy as np  # 导入numpy库
from media.sensor import *
from media.display import *
from media.media import *
from machine import UART, FPIOA,Pin,Timer

#x轴是串口3
#y轴是串口2
# --------------------------- 硬件初始化 ---------------------------
# 串口初始化
fpioa = FPIOA()
fpioa.set_function(49,FPIOA.GPIO49)

fpioa.set_function(5, FPIOA.UART2_TXD)
fpioa.set_function(6, FPIOA.UART2_RXD)
fpioa.set_function(32, FPIOA.UART3_TXD)
fpioa.set_function(33, FPIOA.UART3_RXD)
LED=Pin(49, Pin.OUT, pull=Pin.PULL_NONE, drive=7)
LED.high()  # GPIO49一直保持高电平
uart2 = UART(UART.UART2, baudrate=115200, bits=UART.EIGHTBITS, parity=UART.PARITY_NONE, stop=UART.STOPBITS_ONE)
uart3 = UART(UART.UART3, baudrate=115200, bits=UART.EIGHTBITS, parity=UART.PARITY_NONE, stop=UART.STOPBITS_ONE)
set_origin=bytes([0x01,0x93,0x88,0x01,0x6B])
trigger_zero=bytes([0x01,0x93,0x88,0x01,0x6B])
pid_y={"KP":0.4,"KI":0.3,"KD":0.4,"Error":0,"LastError":0,"LastLasterror":0}
pid_x={"KP":0.4,"KI":0.3,"KD":0.4,"Error":0,"LastError":0,"LastLasterror":0}
cond={"math":0}
flag={"flag":1}
# 屏幕分辨率设置
lcd_width = 800
lcd_height = 480

# 摄像头初始化（注意：保留RGB模式用于色块检测，后续转为灰度图用于矩形检测）
sensor = Sensor(id=2)
sensor.reset()
sensor.set_framesize(width=800, height=480)  # 降低分辨率提高帧率
sensor.set_pixformat(Sensor.RGB565)  # 保留彩色用于紫色色块检测

# 显示初始化
Display.init(Display.ST7701, width=lcd_width, height=lcd_height, to_ide=True)
MediaManager.init()
sensor.run()

# --------------------------- 配置参数 ---------------------------
# 矩形检测核心参数（基于cv_lite）
canny_thresh1      = 50        # Canny边缘检测低阈值
canny_thresh2      = 150       # Canny边缘检测高阈值
approx_epsilon     = 0.04      # 多边形拟合精度（越小越精确）
area_min_ratio     = 0.005     # 最小面积比例（相对于图像总面积）
max_angle_cos      = 0.3       # 角度余弦阈值（越小越接近矩形）
gaussian_blur_size = 3         # 高斯模糊核尺寸（奇数）

# 原有筛选参数
MIN_AREA = 100               # 最小面积阈值
MAX_AREA = 100000             # 最大面积阈值
MIN_ASPECT_RATIO = 1.2        # 最小宽高比 (确保宽>高，横向长方形)
MAX_ASPECT_RATIO = 4.0        # 最大宽高比 (允许较长的横向长方形)
# --------------------------- 工具函数 ---------------------------
def connect(direct1,plus1,direct2,plus2):
    uart2.write(bytes([0x01,0xFD]))
    uart2.write(direct2)
    uart2.write(bytes([0x05,0xDC,0x0A]))
    uart2.write(plus2)
    uart2.write(bytes([0x00,0x00,0x6B]))
    uart3.write(bytes([0x01,0xFD]))
    uart3.write(direct1)
    uart3.write(bytes([0x05,0xDC,0x0A]))
    uart3.write(plus1)
    uart3.write(bytes([0x00,0x00,0x6B]))
def format_to_hex_bytes(value):
    if not (0 <= value <= 0xFFFFFFFF):
        raise ValueError("Value out of 32-bit unsigned range")
    return value.to_bytes(4, 'big')
def control(target,actural):
    pid_y["LastLasterror"]=pid_y["LastError"]
    pid_x["LastLasterror"]=pid_x["LastError"]
    pid_y["LastError"]=pid_y["Error"]
    pid_x["LastError"]=pid_x["Error"]
    pid_x["Error"]=target[0]-actural[0]
    pid_y["Error"]=target[1]-actural[1]
    out_y=pid_y["KP"]*(pid_y["Error"]-pid_y["LastError"])+pid_y["KI"]*pid_y["Error"]+pid_y["KD"]*(pid_y["Error"]-2*pid_y["LastError"]+pid_y["LastLasterror"])
    out_x=pid_x["KP"]*(pid_x["Error"]-pid_x["LastError"])+pid_x["KI"]*pid_x["Error"]+pid_x["KD"]*(pid_x["Error"]-2*pid_x["LastError"]+pid_x["LastLasterror"])
    if pid_x["Error"]<2 and pid_y["Error"]<2 and flag["flag"]==1:
        cond["math"]+=1
        if cond["math"]>=20:
            # GPIO49保持高电平，不进行开关操作
            print("目标锁定！GPIO49保持高电平")
            flag["flag"]=0
    if out_y>0:
        direct_y=0x00  # 目标在下方，云台向下转
    else:
        direct_y=0x01  # 目标在上方，云台向上转
        out_y=-out_y
    if out_x>0:
        direct_x=0x00
    else:
        direct_x=0x01
        out_x=-out_x
    out_y=format_to_hex_bytes(int(out_y))
    out_x=format_to_hex_bytes(int(out_x))
    connect(bytes([direct_x]),out_x,bytes([direct_y]),out_y)
def calculate_distance(p1, p2):
    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])** 2)

def calculate_center(points):
    if not points:
        return (0, 0)
    sum_x = sum(p[0] for p in points)
    sum_y = sum(p[1] for p in points)
    return (sum_x / len(points), sum_y / len(points))

def is_valid_rect(corners):
    edges = [calculate_distance(corners[i], corners[(i+1)%4]) for i in range(4)]

    # 对边比例校验
    ratio1 = edges[0] / max(edges[2], 0.1)
    ratio2 = edges[1] / max(edges[3], 0.1)
    valid_ratio = 0.5 < ratio1 < 1.5 and 0.5 < ratio2 < 1.5

    # 面积校验
    area = 0
    for i in range(4):
        x1, y1 = corners[i]
        x2, y2 = corners[(i+1) % 4]
        area += (x1 * y2 - x2 * y1)
    area = abs(area) / 2
    valid_area = MIN_AREA < area < MAX_AREA

    # 宽高比校验
    width = max(p[0] for p in corners) - min(p[0] for p in corners)
    height = max(p[1] for p in corners) - min(p[1] for p in corners)
    aspect_ratio = width / max(height, 0.1)
    valid_aspect = MIN_ASPECT_RATIO < aspect_ratio < MAX_ASPECT_RATIO

    return valid_ratio and valid_area and valid_aspect
def sort_corners(corners):
    """将矩形角点按左上、右上、右下、左下顺序排序"""
    center = calculate_center(corners)
    sorted_corners = sorted(corners, key=lambda p: math.atan2(p[1]-center[1], p[0]-center[0]))

    # 调整顺序为左上、右上、右下、左下
    if len(sorted_corners) == 4:
        left_top = min(sorted_corners, key=lambda p: p[0]+p[1])
        index = sorted_corners.index(left_top)
        sorted_corners = sorted_corners[index:] + sorted_corners[:index]
    return sorted_corners
# --------------------------- 主循环 ---------------------------
clock = time.clock()
image_shape = [sensor.height(), sensor.width()]  # [高, 宽] 用于cv_lite
try:
    while True:
        #LED.on()
        os.exitpoint()
        clock.tick()
        img = sensor.snapshot()
        # 2. 矩形检测（使用cv_lite替换原有实现）
        # 2.1 将RGB图像转为灰度图（用于矩形检测）
        gray_img = img.to_grayscale()
        img_np = gray_img.to_numpy_ref()  # 转为numpy数组供cv_lite使用
        # 2.2 调用cv_lite矩形检测函数（带角点）
        rects = cv_lite.grayscale_find_rectangles_with_corners(
            image_shape,       # 图像尺寸 [高, 宽]
            img_np,            # 灰度图数据
            canny_thresh1,     # Canny低阈值
            canny_thresh2,     # Canny高阈值
            approx_epsilon,    # 多边形拟合精度
            area_min_ratio,    # 最小面积比例
            max_angle_cos,     # 角度余弦阈值
            gaussian_blur_size # 高斯模糊尺寸
        )
        # 3. 筛选最小矩形（保留原有逻辑）
        min_area = float('inf')
        smallest_rect = None
        smallest_rect_corners = None  # 存储最小矩形的角点

        for rect in rects:
            # rect格式: [x, y, w, h, c1.x, c1.y, c2.x, c2.y, c3.x, c3.y, c4.x, c4.y]
            x, y, w, h = rect[0], rect[1], rect[2], rect[3]
            # 提取四个角点
            corners = [
                (rect[4], rect[5]),   # 角点1
                (rect[6], rect[7]),   # 角点2
                (rect[8], rect[9]),   # 角点3
                (rect[10], rect[11])  # 角点4
            ]

            # 验证矩形有效性
            if is_valid_rect(corners):
                # 计算面积
                area = w * h  # 直接使用矩形宽高计算面积（更高效）
                # 更新最小矩形
                if area < min_area:
                    min_area = area
                    smallest_rect = (x, y, w, h)
                    smallest_rect_corners = corners

        # 4. 处理最小矩形（修改后：固定虚拟矩形方向）
        if smallest_rect and smallest_rect_corners:
            x, y, w, h = smallest_rect
            corners = smallest_rect_corners

            # 对矩形角点进行排序
            sorted_corners = sort_corners(corners)


            # 绘制矩形边框和角点
            for i in range(4):
                x1, y1 = sorted_corners[i]
                x2, y2 = sorted_corners[(i+1) % 4]
                img.draw_line(x1, y1, x2, y2, color=(255, 0, 0), thickness=2)
            for p in sorted_corners:
                img.draw_circle(p[0], p[1], 5, color=(0, 255, 0), thickness=2)

            # 计算并绘制矩形中心点
            rect_center = calculate_center(sorted_corners)
            rect_center_int = (int(round(rect_center[0])), int(round(rect_center[1])))
            img.draw_circle(rect_center_int[0], rect_center_int[1], 4, color=(0, 255, 255), thickness=2)
            print([rect_center_int[0], rect_center_int[1]])
            control([400,240],[rect_center_int[0], rect_center_int[1]])
        # 5. 显示与性能统计
        fps = clock.fps()
        img.draw_string_advanced(10, 10, 20, f"FPS: {fps:.1f}", color=(255, 255, 255))  # 显示FPS
        img.draw_cross(400,240,5,color=(255,0,0),thickness=1)
        # 显示图像
        Display.show_image(img)
finally:
    sensor.stop()
    Display.deinit()
    MediaManager.deinit()
    gc.collect()
2.追踪旋转
import time, os, sys,gc
import math
import cv_lite  # 导入cv_lite扩展模块
import ulab.numpy as np  # 导入numpy库
from media.sensor import *
from media.display import *
from media.media import *
from machine import UART, FPIOA,Pin,Timer
#x轴是串口3
#y轴是串口2
# --------------------------- 硬件初始化 ---------------------------
# 串口初始化
fpioa = FPIOA()
fpioa.set_function(49,FPIOA.GPIO49)
fpioa.set_function(5, FPIOA.UART2_TXD)
fpioa.set_function(6, FPIOA.UART2_RXD)
fpioa.set_function(32, FPIOA.UART3_TXD)
fpioa.set_function(33, FPIOA.UART3_RXD)
LED=Pin(49, Pin.OUT, pull=Pin.PULL_NONE, drive=7)
uart2 = UART(UART.UART2, baudrate=115200, bits=UART.EIGHTBITS, parity=UART.PARITY_NONE, stop=UART.STOPBITS_ONE)
uart3 = UART(UART.UART3, baudrate=115200, bits=UART.EIGHTBITS, parity=UART.PARITY_NONE, stop=UART.STOPBITS_ONE)
set_origin=bytes([0x01,0x93,0x88,0x01,0x6B])
trigger_zero=bytes([0x01,0x93,0x88,0x01,0x6B])
pid_y={"KP":0.4,"KI":0.3,"KD":0.4,"Error":0,"LastError":0,"LastLasterror":0}
pid_x={"KP":0.4,"KI":0.3,"KD":0.4,"Error":0,"LastError":0,"LastLasterror":0}
cond={"math":0}
flag={"flag":1}
# 屏幕分辨率设置
lcd_width = 800
lcd_height = 480

# 摄像头初始化（注意：保留RGB模式用于色块检测，后续转为灰度图用于矩形检测）
sensor = Sensor(id=2)
sensor.reset()
sensor.set_framesize(width=800, height=480)  # 降低分辨率提高帧率
sensor.set_pixformat(Sensor.RGB565)  # 保留彩色用于紫色色块检测

# 显示初始化
Display.init(Display.ST7701, width=lcd_width, height=lcd_height, to_ide=True)
MediaManager.init()
sensor.run()

# --------------------------- 配置参数 ---------------------------
# 矩形检测核心参数（基于cv_lite）
canny_thresh1      = 50        # Canny边缘检测低阈值
canny_thresh2      = 150       # Canny边缘检测高阈值
approx_epsilon     = 0.04      # 多边形拟合精度（越小越精确）
area_min_ratio     = 0.005     # 最小面积比例（相对于图像总面积）
max_angle_cos      = 0.3       # 角度余弦阈值（越小越接近矩形）
gaussian_blur_size = 3         # 高斯模糊核尺寸（奇数）

# 原有筛选参数
MIN_AREA = 100               # 最小面积阈值
MAX_AREA = 100000             # 最大面积阈值
MIN_ASPECT_RATIO = 1.2        # 最小宽高比 (确保宽>高，横向长方形)
MAX_ASPECT_RATIO = 4.0        # 最大宽高比 (允许较长的横向长方形)
# --------------------------- 工具函数 ---------------------------
# 张大头电机正确协议函数
def zhang_datou_speed_control(uart, direction, speed_rpm):
    """张大头电机速度控制 - 官方协议"""
    # 速度转换为高低字节 (16位)
    speed_high = (speed_rpm >> 8) & 0xFF
    speed_low = speed_rpm & 0xFF
    acceleration = 0x0A  # 加速度档位10
    sync_flag = 0x00     # 不启用多机同步

    # 官方协议: 地址 + 0xF6 + 方向 + 速度高字节 + 速度低字节 + 加速度 + 同步标志 + 校验字节
    uart.write(bytes([0x01, 0xF6, direction, speed_high, speed_low, acceleration, sync_flag, 0x6B]))

def zhang_datou_stop(uart):
    """张大头电机停止 - 立即停止命令"""
    # 官方协议: 地址 + 0xFE + 0x98 + 多机同步标志 + 校验字节
    uart.write(bytes([0x01, 0xFE, 0x98, 0x00, 0x6B]))

def connect(direct1,plus1,direct2,plus2):
    uart2.write(bytes([0x01,0xFD]))
    uart2.write(direct2)
    uart2.write(bytes([0x05,0xDC,0x0A]))
    uart2.write(plus2)
    uart2.write(bytes([0x00,0x00,0x6B]))
    uart3.write(bytes([0x01,0xFD]))
    uart3.write(direct1)
    uart3.write(bytes([0x05,0xDC,0x0A]))
    uart3.write(plus1)
    uart3.write(bytes([0x00,0x00,0x6B]))
def format_to_hex_bytes(value):
    if not (0 <= value <= 0xFFFFFFFF):
        raise ValueError("Value out of 32-bit unsigned range")
    return value.to_bytes(4, 'big')
def control(target,actural):
    pid_y["LastLasterror"]=pid_y["LastError"]
    pid_x["LastLasterror"]=pid_x["LastError"]
    pid_y["LastError"]=pid_y["Error"]
    pid_x["LastError"]=pid_x["Error"]
    pid_x["Error"]=target[0]-actural[0]
    pid_y["Error"]=target[1]-actural[1]
    out_y=pid_y["KP"]*(pid_y["Error"]-pid_y["LastError"])+pid_y["KI"]*pid_y["Error"]+pid_y["KD"]*(pid_y["Error"]-2*pid_y["LastError"]+pid_y["LastLasterror"])
    out_x=pid_x["KP"]*(pid_x["Error"]-pid_x["LastError"])+pid_x["KI"]*pid_x["Error"]+pid_x["KD"]*(pid_x["Error"]-2*pid_x["LastError"]+pid_x["LastLasterror"])
    if pid_x["Error"]<20 and pid_y["Error"]<2 and flag["flag"]==1:
        cond["math"]+=1
        if cond["math"]>=5:#帧数
            LED.on()
            time.sleep_ms(200)
            LED.off()
            flag["flag"]=0
    if out_y>0:
        direct_y=0x00  # 目标在上方，云台向上转
    else:
        direct_y=0x01  # 目标在下方，云台向下转
        out_y=-out_y
    if out_x>0:
        direct_x=0x00
    else:
        direct_x=0x01
        out_x=-out_x
    out_y=format_to_hex_bytes(int(out_y))
    out_x=format_to_hex_bytes(int(out_x))
    connect(bytes([direct_x]),out_x,bytes([direct_y]),out_y)
def calculate_distance(p1, p2):
    return math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])** 2)

def calculate_center(points):
    if not points:
        return (0, 0)
    sum_x = sum(p[0] for p in points)
    sum_y = sum(p[1] for p in points)
    return (sum_x / len(points), sum_y / len(points))

def is_valid_rect(corners):
    edges = [calculate_distance(corners[i], corners[(i+1)%4]) for i in range(4)]

    # 对边比例校验
    ratio1 = edges[0] / max(edges[2], 0.1)
    ratio2 = edges[1] / max(edges[3], 0.1)
    valid_ratio = 0.5 < ratio1 < 1.5 and 0.5 < ratio2 < 1.5

    # 面积校验
    area = 0
    for i in range(4):
        x1, y1 = corners[i]
        x2, y2 = corners[(i+1) % 4]
        area += (x1 * y2 - x2 * y1)
    area = abs(area) / 2
    valid_area = MIN_AREA < area < MAX_AREA

    # 宽高比校验
    width = max(p[0] for p in corners) - min(p[0] for p in corners)
    height = max(p[1] for p in corners) - min(p[1] for p in corners)
    aspect_ratio = width / max(height, 0.1)
    valid_aspect = MIN_ASPECT_RATIO < aspect_ratio < MAX_ASPECT_RATIO

    return valid_ratio and valid_area and valid_aspect
def sort_corners(corners):
    """将矩形角点按左上、右上、右下、左下顺序排序"""
    center = calculate_center(corners)
    sorted_corners = sorted(corners, key=lambda p: math.atan2(p[1]-center[1], p[0]-center[0]))

    # 调整顺序为左上、右上、右下、左下
    if len(sorted_corners) == 4:
        left_top = min(sorted_corners, key=lambda p: p[0]+p[1])
        index = sorted_corners.index(left_top)
        sorted_corners = sorted_corners[index:] + sorted_corners[:index]
    return sorted_corners
# --------------------------- 主循环 ---------------------------
clock = time.clock()
image_shape = [sensor.height(), sensor.width()]  # [高, 宽] 用于cv_lite
try:
    while True:
        #LED.on()
        os.exitpoint()
        clock.tick()
        img = sensor.snapshot()
        # 2. 矩形检测（使用cv_lite替换原有实现）
        # 2.1 将RGB图像转为灰度图（用于矩形检测）
        gray_img = img.to_grayscale()
        img_np = gray_img.to_numpy_ref()  # 转为numpy数组供cv_lite使用
        # 2.2 调用cv_lite矩形检测函数（带角点）
        rects = cv_lite.grayscale_find_rectangles_with_corners(
            image_shape,       # 图像尺寸 [高, 宽]
            img_np,            # 灰度图数据
            canny_thresh1,     # Canny低阈值
            canny_thresh2,     # Canny高阈值
            approx_epsilon,    # 多边形拟合精度
            area_min_ratio,    # 最小面积比例
            max_angle_cos,     # 角度余弦阈值
            gaussian_blur_size # 高斯模糊尺寸
        )
        # 3. 筛选最小矩形（保留原有逻辑）
        min_area = float('inf')
        smallest_rect = None
        smallest_rect_corners = None  # 存储最小矩形的角点

        for rect in rects:
            # rect格式: [x, y, w, h, c1.x, c1.y, c2.x, c2.y, c3.x, c3.y, c4.x, c4.y]
            x, y, w, h = rect[0], rect[1], rect[2], rect[3]
            # 提取四个角点
            corners = [
                (rect[4], rect[5]),   # 角点1
                (rect[6], rect[7]),   # 角点2
                (rect[8], rect[9]),   # 角点3
                (rect[10], rect[11])  # 角点4
            ]

            # 验证矩形有效性
            if is_valid_rect(corners):
                # 计算面积
                area = w * h  # 直接使用矩形宽高计算面积（更高效）
                # 更新最小矩形
                if area < min_area:
                    min_area = area
                    smallest_rect = (x, y, w, h)
                    smallest_rect_corners = corners

        # 4. 处理最小矩形（修改后：固定虚拟矩形方向）
        if smallest_rect and smallest_rect_corners:
            x, y, w, h = smallest_rect
            corners = smallest_rect_corners

            # 对矩形角点进行排序
            sorted_corners = sort_corners(corners)

            # 绘制矩形边框和角点
            for i in range(4):
                x1, y1 = sorted_corners[i]
                x2, y2 = sorted_corners[(i+1) % 4]
                img.draw_line(x1, y1, x2, y2, color=(255, 0, 0), thickness=2)
            for p in sorted_corners:
                img.draw_circle(p[0], p[1], 5, color=(0, 255, 0), thickness=2)

            # 计算并绘制矩形中心点
            rect_center = calculate_center(sorted_corners)
            rect_center_int = (int(round(rect_center[0])), int(round(rect_center[1])))
            img.draw_circle(rect_center_int[0], rect_center_int[1], 4, color=(0, 255, 255), thickness=2)

            # 显示追踪状态
            img.draw_string_advanced(10, 40, 16, "MODE: TRACKING", color=(0, 255, 0))
            print([rect_center_int[0], rect_center_int[1]])
            control([400,240],[rect_center_int[0], rect_center_int[1]])
        else:
            # 没有识别到矩形，慢向右旋转搜索
            img.draw_string_advanced(10, 40, 16, "MODE: SEARCHING", color=(255, 255, 0))

            # 使用正确的张大头协议进行搜索
            search_speed_rpm = 12  # 搜索速度 RPM

            # X轴向右转 (UART3, 方向0x01=CCW)
            zhang_datou_speed_control(uart3, 0x01, search_speed_rpm)

            # Y轴停止 (UART2)
            zhang_datou_stop(uart2)
        # 5. 显示与性能统计
        fps = clock.fps()
        img.draw_string_advanced(10, 10, 20, f"FPS: {fps:.1f}", color=(255, 255, 255))  # 显示FPS
        img.draw_cross(400,240,5,color=(255,0,0),thickness=1)
        # 显示图像
        Display.show_image(img)
finally:
    sensor.stop()
    Display.deinit()
    MediaManager.deinit()
    gc.collect()